*************************************************** Pattern 1 *************************************************************

if you have given  the target, and have find the max/min in path/cost/sum:
===========================================================================================================================
appoach:(top down) -> memoization
---------------------------------------------------------------------------------------------------------------------------
returnType Solve(..arguments){

    //base condition

    //dp returning

    for(int j=0; j<ways.size(); j++){
        result = min(result, Solve(target-ways[j])) + path/cost/sum
    }
    return memo[/state parameter/] = result;
}
============================================================================================================================
appoach(bottom up) -> 
----------------------------------------------------------------------------------------------------------------------------
for (int i = 1; i <= target; ++i) {
   for (int j = 0; j < ways.size(); ++j) {
       if (ways[j] <= i) {
           dp[i] = min(dp[i], dp[i - ways[j]] + cost / path / sum) ;
       }
   }
}
 
return dp[target]
==============================================================================================================================
